1.浅拷贝

通过循环，将a对象的属性和方法拷贝给b属性，但是由于拷贝时a对象内部的引用数据类型时，其值为堆里该引用数据类型的地址值，所以会造成a、b两个对象中的引用数据类型指向堆中同一块内存地址，这会造成牵一发而动全身，改动a的引用数据类型会导致b中的该值也受到牵连。

```javascript
var a = {
      name:"objectaaaaa",
      go:function(){
        console.log("这是对象a的方法")
      },
      another:{
        name:"不知道"
      },
      have:[1,2,5,6] 
    }

    var b = {}
    for(var key in a){
      b[key] = a[key]
    }
    a.name = "wwwwqq"
    a.another.name = "hahah"
    console.log("a",a)
    console.log("b",b)
```

2、深拷贝

通过递归的方式对对象的引用数据类型当作一个新的对象再进行浅拷贝在赋值，这样就可以确保二者的地址值指向堆中地址不一样。

```javascript
var a = {
      name:"objectaaaaa",
      go:function(){
        console.log("这是对象a的方法")
      },
      another:{
        name:"不知道"
      },
      have:[1,2,5,6] 
    }

    var b = {}
    // for(var key in a){
    //   b[key] = a[key]
    // }

    function deepCopy(a,b){
      for(var key in a){
        if(a[key] instanceof Array){
          b[key] = []
          deepCopy(a[key],b[key])
        }else if(a[key] instanceof Object){
          if(a[key] instanceof Function){
            b[key] = a[key]
          }else{
            b[key] = {}
            deepCopy(a[key],b[key])
          }
        }else{
          b[key] = a[key]
        }
      }
    }
    deepCopy(a,b)
    a.name = "wwwwqq"
    a.another.name = "hahah"
    console.log("a",a)
    console.log("b",b)
    b.go = function(){
      console.log("this is b")
    }
    b.go()
    a.go()
```


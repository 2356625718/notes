+ http和https

  http：超文本传输协议，是客户端和服务端请求与应答的标准（TCP）

  https：http协议+SSL协议（安全套接字）：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。

  区别：

  1、https协议需要ca证书，费用较高

  2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

  3、采用不同的链接方式，端口也不同。http：80，https：443

  4、http的链接简单，无状态，https协议则是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议更安全。

  https协议工作原理：

  1、浏览器发起http请求，要求服务器建立ssl链接。

  2、服务器收到请求之后，会将网站的证书（包含公钥）返回给客户端。

  3、客户端和服务器端开始协商ssl链接的安全等级，也就是加密等级。

  4、客户端通过双方协商一致的安全等级，建立会话密钥，通过网站的公钥来加密会话密钥，并传送给网站。

  5、web服务器通过自己的私钥解密出会话密钥

  6、web服务器通过会话密钥加密与客户端之间的通信

  https协议的缺点：

  1、https握手阶段比较费事，会使页面加载时间延长50%，增加10%-20%的耗电。

  2、https缓存不如http高效，会增加数据开销。

  3、SSL证书也需要钱，功能越强大的证书价格越高。

  4、能在同一个ip上绑定同一个域名，ipv4不支持这种消耗。

  

+ TCP和UDP的区别

  1、TCP是面向连接的，UDP是无连接的，即发送数据前不需要先建立连接。

  2、TCP提供可靠的服务，而UDP是尽最大的努力交付。

  3、TCP是面向字节流，而UDP面向报文，并且网络阻塞不会使得发送速率降低，但此时会出现丢包。

  4、TCP只能是1对1，而UDP支持1对1，1对多。

  5、TCP首部较大为20个字节，UDP仅为8字节。

  6、TCP是面向连接的可靠性传输，而UDP是不可靠的。

+ websocket：websocket是HTML5中的协议，支持持久连续，http协议不支持持久性连接。HTTP1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive将多个http请求合并为1个。

  在HTTP1.0中，1个request对应一个response，一次HTTP请求只能请求一次

  在HTTP1.1中，一次htpp请求可以请求多次，但仍然是一个request对应一个response此时多了一个标头Connection:keep-alive

​       而websocket是基于http协议的或者说借用了http协议来完成一部分握手，websocket协议握手阶段的实现多了两个标头：

​       1、Upgrade：webSocket

​       2、Connection：Upgrade

​       来告诉服务器发送的是webSocket

+ head请求：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头。

  options请求：允许服务端查看服务器性能，比如服务器支持的请求方式。

  

+ 图片url访问后直接下载：请求的返回头里面，用于浏览器解析的重要参数就是OSS的API文档里面的返回http文档，决定用户下载行为的参数。

  1、x-oss-object-type：Normal

  2、x-oss-request-id：编码串

  3、x-oss-storage-class：Standard

+ web quality（无障碍）：alt属性的使用有助于浏览器为残障人士显示或读出有关图像的描述。

+ 使用BOM属性对象方法：

  1、location对象

  location.href：返回或设置当前文档的url

  location.search: 返回url中查询字符串的部分（？后面的内容）

  location.hash:返回url中的hash值（#后面的内容）

  location.host：返回url中的域名

  location.hostname：返回url中的主域名部分

  location.pathname: 返回URL中的域名后的部分

  location.port：返回url中的端口值

  location.protocol：返回url中的协议部分

  location.assign：设置当前文档的url

  location.replace（）：设置当前文档的url，并在history对象的地址列表中移除这个url

  location.reload（）：重载当前页面

  2、history对象

  history.go():前进或后退指定的页数

  history.back（）：后退一页

  history.forward（）：前进一页

  3、navigator对象

  navigator.userAgent：返回用户代理头的字符串表示

  navigator.cookieEnabled：返回浏览器是否支持cookie

+ HTML5 drag api

  1、dragstart：事件主体是被拖放元素，开始拖放时触发

  2、drag：事件主体是被拖放元素，在正在拖放时触发。

  3、dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。

  4、dragover：事件主体是目标元素，被拖放元素在某一元素内移动时触发。

  5、dragleave：事件主体是目标元素，被拖放元素离开某一元素时触发。

  6、drop：事件主体是目标元素，目标元素完全接受拖放元素时触发。

  7、dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。

  

+ Http2.0

  http2.0是基于1999年发布的http1.0的首次更新。

  优点：

  1、提升访问速度。

  2、允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。

  3、二进制分帧

  4、首部压缩

  5、服务器端推送

+ 状态码

  1、400:请求无效

  产生原因：前端提交数据的字段名称和字段类型与后台的实体没有保持一致，或者没有将JSON字符串化

  2、401:当前请求需要用户验证

  3、403:服务器得到请求，但是拒绝执行

+ fetch发送两次请求的原因：

  fetch发送post请求的时候总是发送两次，第一次状态码是204，第二次才成功。

  原因：fetch发送post请求第一次会先发送options请求，询问服务器是否支持修改的请求头，服务器支持则发送第二次真正的请求。

+ HTML语义化标签：正确的标签包含正确的内容，结构良好，便于阅读。

+ iframe：会创建包含另一个文档的内联框架。

  缺点：1、会阻塞主页面的onload事件

  2、搜索引擎无法解读这种页面，不利于SEO

  3、iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。

+ Doctype作用：Doctype声明位于文档最前面，告诉浏览器以何种方式来渲染页面：严格模式或混杂模式

  严格模式：排版和js运作模式是以该浏览器支持的最高标准运行

  混杂模式：向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。

  

+ Cookie如何防范XSS攻击

  1、XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入了javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：a、httponly这个属性可以防止XSS，它会禁止js脚本来访问cookie。b、secure这个属性告诉浏览器仅在请求为https的时候发送cookie

+ Cookie和session的区别

  HTTP是一个无状态的协议，因此Cookie的最大的作用就是存储sessionid用来唯一标识用户。

  

+ RESTFUL：URL定位资源，HTTP描述操作。

+ click在ios上有300ms延迟，原因及如何解决？

  1、粗暴型，禁用缩放

  ```javascript
  <meta name="viewport" content="width=device-width,user-scalable=no"
  ```

  2、利用fastclick：监测到touchend事件后，立刻出发模拟click事件，并且把浏览器300ms之后的事件给阻断掉。

+ iframe通信：同源：根据父页面以及cookie

  不同源：设置子域
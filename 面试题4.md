1、css盒模型

ie盒模型：宽高包括content+padding+border

标准盒子模型：宽高只有content

box-sizing：boder-box开启ie盒模型

box-sizing：content-box开启标准盒模型

2、画一条0.5px的线

```javascript
#line::after {
        content:'';
        display:block;
        height: 1px;
        background-color: black;
        transform: scale(1, 0.5);
      }
```

3、link标签和@import的区别

a、link是html标签，@import是css提供的

b、页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。

c、link是html标签，因此没有兼容性，而@import只有ie5以上才能够识别。

d、link方式的权重高于@import

4、transition和animation的区别：

1、transtion需要触发事件，animation不需要触发事件

2、transition为2帧，而animation可以一帧一帧的

5、BFC：块级格式化上下文，用来清除浮动，避免margin重叠

生成方法：a、根元素 b、float不为none的元素 c、position为fixed和absolute的元素 d、display为inline-block、table-cell、table-caption、flex、inline-flex e、overflow不为visible的元素

6、js动画和css3动画的差异性

渲染线程分为main thread和compositor thread，如果css动画只改变transform和opacity，便只在compositor thread线程完成，而js动画会先在main thread执行，然后出发到compositor thread进行下一步操作。

区别：

a、功能涵盖面，js比css广

b、实现、重构难度不一，css3比js更加简单，性能调优方向固定。

c、对帧速表现不好的低版本浏览器，css可以做到自然降级

d、css动画有天然事件支持

e、css3有兼容性问题

7、多行元素的文本省略号:

```javascript
#span {
        width: 300px;
        word-wrap: break-word;
        display: -webkit-box;
        -webkit-box-orient:vertical;
        -webkit-line-clamp:3;
         overflow:hidden
      }
```

8、visibility：hidden、opacity：0和display：none区别：visibility只是隐藏元素，布局所占和点击事件仍旧会触发，opacity仍占布局空间，但不会触发事件，display不占空间也不会触发事件。

9、双边距重叠问题：正值取最大，负值取最小，一正一负取和

10、浮动清除：1、使用带clear的空元素 2、使用overflow创建kfc 3、

11、选择器：id、class、标签、伪元素选择器、伪类选择器

12、css3中对溢出的处理：text-overflow属性，值为clip是修剪文本，ellipsis显示省略符号、string显示给定字符串。

13、calc属性：用于动态计算长度值，需要注意的是，运算符前后都需要保留一个空格：calc（100% - 10px）

14、inline-block、inline和block的区别：

a、block是块级元素，前后有换行符，高宽margin和padding都有效

b、inline时width和height无效，margin在竖直方向上无效，前后无换行符

c、inline-block能设置宽高，margin、padding都有效，前后无换行符。

15、重绘和重排的概念，减少重绘和重排：

概念：DOM变化使浏览器重新计算元素的几何属性，其他元素的几何属性也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排，浏览器将受到影响的部分重新重新绘制到屏幕上，这个过程称为重绘。重新构建渲染树的过程称为回流。

引起重排和重绘的原因：1、添加或者删除可见的DOM元素

2、元素尺寸位置的变化

3、浏览器窗口大小发生改变

重排一定引发重绘，重绘不一定引发重排。

减少重排和重绘的办法：

1、不在布局信息改变时做dom查询

2、使用csstext或classname一次性改变属性

3、使用createDocumentFragment一次性插入元素

4、对于多次重排的元素，使用绝对定位脱离文档流，使其不影响其他元素。

16、css布局方式：圣杯布局、双飞翼布局、flex布局、绝对定位布局、表格布局、网格布局（grid）

17、闭包：能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。

18、类的创建和继承：

创建：function（es5，方法名大写），class（es6）

继承：1、原型链继承：将原型对象指向要继承对象的实例 缺点：无法实现多继承 

2、构造继承：在构造函数中使用call函数对要继承对象进行继承 缺点：无法继承原型上的属性和方法

3、实例继承

4、拷贝继承

5、组合继承：原型链继承和构造继承的组合体。缺点：调用了两次父类构造函数，生成了两份实例

6、寄生组合继承：通过寄生方式，砍掉父类的实例属性：

```javascript
//Cat继承Animal
function Cat () {
  Animal.call()
}

(function () {
  function Super () {}
  Super.prototype = Animal.prototype
  Cat.prototype = new Super()
})()
```

19 、如何解决回调地狱：Promise、generator、async/await

20、预加载和懒加载：预加载提前加载图片，懒加载减少请求数或延迟请求数，前者加重服务器负担，后者减轻服务器负担。

21、js的各种位置：

a、clientHeight：可视区域高度，不包括border和滚动条

b、offsetHeight：可视区域高度，包括border和滚动条

c、scrollHeight：所有区域高度

d、clientTop：边框区域的厚度

e、scrollTop：滚动后被隐藏的高度

22、js拖拽功能的实现

使用3个方法mousedown、mousemove、mouseup，元素位置=move时的坐标-down时的坐标+初始元素的offsetLeft

也可以通过html5中dray和drop的api来实现

23、异步加载js的方法

1、defer：仅支持ie

2、async：html5属性，在ie中，defer优先级比async更高

3、创建script标签，插入到dom中。

24、ajax解决浏览器缓存问题：

1、在ajax发送请求前加上xhr.setRequestHeader("If-Modified-Since","0")

2、在ajax发送请求前加上xhr.setRequestHeader("Cache-Control","no-cache")

3、在url后面加上随机数"fresh="+Math.random()

4、在url后面加上时间戳"nowtime="+new Date().getTime()

25、前端模块化：将复杂的文件划分为一个个模块，比如js文件等等，分成独立的模块有利于重用和维护，这样会引来模块之间相互依赖的问题，所以有了commonjs、AMD、CMD规范，以及用于js打包的工具webpack。

26、深拷贝：直接赋值时object无法深拷贝，object又分为对象和数组，在深拷贝函数里进行递归拷贝完成深拷贝

27、js监听对象属性的改变：

1、在es5中有Object.defineProperty来实现已有属性的监听,无法监听不存在的属性，而且无法监听数组的变化

```javascript
Object.defineProperty(obj, 'property', {
  set: function (target, key, value, receiver) {
    
  }
})
```

2、在es6中有proxy，可以监听不存在的属性

```javascript
let user = new Proxy({}, {
  set: function (target, key, value, receiver) {
    
  }
})
```

28、requestAnimationFrame（callback）不需要设置时间间隔，默认采用系统时间间隔，优点：

1、requestAnimationFrame会把所有DOM操作集中起来在一次重绘或回流，并且重绘和回流的时间间隔紧紧跟随浏览器的刷新频率。

2、在隐藏和不可见的元素中将不会进行重绘和回流。

3、requestAnimationFrame是浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且页面不是激活状态动画会自动暂停。

29、Promise/A+规范：

1、Promise有三个状态：等待态（Pending）、执行态（Fulfilled）、拒绝态（Rejected）

2、状态从等待态转换成执行态或者拒绝态之后就不能够再改变状态

3、then函数中参数onFulfilled和onRejected是可选的，并且不是函数时应被忽略

4、then方法必须返回一个Promise对象，promise2 = promise1.then（onFulfilled， onRejected） 

30、js判断类型

typeof、instanceof、Object.prototype.toString.call()

31、数组常用方法：push、pop、shift、unshift、splice、sort、reverse、map

32、数组去重：1、indexOf循环去重 2、ES6 set去重： Array.form(new set(arr)) 3、Object键值对去重